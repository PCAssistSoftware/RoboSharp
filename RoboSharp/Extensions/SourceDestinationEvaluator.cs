using RoboSharp.Interfaces;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace RoboSharp.Extensions
{
    /// <summary>
    /// Class that can be instantiated to cache the various values that get checked against when deciding to copy a file or folder.
    /// <br/> Custom Implementations can instantiate this class and use it to assist with evaluating if they need to copy a file, generate the ProcessedFileInfo objects, etc.
    /// </summary>
    public class SourceDestinationEvaluator
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="command"></param>
        public SourceDestinationEvaluator(IRoboCommand command)
        { 
            AssociatedCommand = command;
            FileAttributesToApplyField = SelectionOptions.ConvertFileAttrStringToEnum(command.CopyOptions.AddAttributes);
            FileAttributesToRemoveField = SelectionOptions.ConvertFileAttrStringToEnum(command.CopyOptions.RemoveAttributes);
        }

        #region < Properties >

        /// <summary>
        /// The IRoboCommand object this evaluator is tied to
        /// </summary>
        public IRoboCommand AssociatedCommand { get; }

        /// <summary>
        /// Regex objects generated by <see cref="CopyOptionsExtensions.ShouldIncludeFileName(CopyOptions, IFileSourceDestinationPair, ref Regex[])"/>
        /// </summary>
        public Regex[] IncludeFileNameRegex => IncludeFileNameRegexField;
        private Regex[] IncludeFileNameRegexField;

        /// <summary>
        /// Regex objects generated by <see cref="SelectionOptionsExtensions.ShouldExcludeFileName(SelectionOptions, IFileSourceDestinationPair, ref Regex[])"/>
        /// </summary>
        public Regex[] ExcludeFileNameRegex => ExcludeFileNameRegexField;
        private Regex[] ExcludeFileNameRegexField;

        private Tuple<bool, Regex>[] DirectoryNameRegexExclusions;

        /// <summary>
        /// File Attributes to add - Gathered from <see cref="CopyOptions.AddAttributes"/> when instantiated.
        /// </summary>
        public FileAttributes? FileAttributesToApply => FileAttributesToApplyField;
        private FileAttributes? FileAttributesToApplyField;

        /// <summary>
        /// File Attributes to remove - Gathered from <see cref="CopyOptions.RemoveAttributes"/> when instantiated.
        /// </summary>
        public FileAttributes? FileAttributesToRemove => FileAttributesToRemoveField;
        private FileAttributes? FileAttributesToRemoveField;

        #endregion

        #region < ShouldCopyDir >

        /// <summary>
        /// Compare the Source/Destination directories, and decide if the directory should be copied down.
        /// </summary>
        /// <param name="pair">the pair to evaluate</param>
        /// <param name="info">the generated ProcessedFileInfo</param>
        /// <param name="dirClass">The dirClass applied to the <paramref name="info"/></param>
        /// <param name="ExcludeDirectoryName">Result of <see cref="ShouldExcludeDirectoryName(IDirectorySourceDestinationPair)"/></param>
        /// <param name="ExcludeJunctionDirectory">Result of <see cref="ShouldExcludeJunctionDirectory(IDirectorySourceDestinationPair)"/></param>
        /// <returns>TRUE if the directory would be excluded based on the current IROboCommand settings, otherwise false</returns>
        public virtual bool ShouldCopyDir(IDirectorySourceDestinationPair pair, out ProcessedFileInfo info, out DirectoryClasses dirClass, out bool ExcludeJunctionDirectory, out bool ExcludeDirectoryName)
        {
            ExcludeDirectoryName = ShouldExcludeDirectoryName(pair);
            ExcludeJunctionDirectory = ShouldExcludeJunctionDirectory(pair);
            
            bool shouldExclude = ExcludeJunctionDirectory | ExcludeDirectoryName;
            if (!shouldExclude && pair.Source.Exists && pair.Destination.Exists)
            {
                dirClass = DirectoryClasses.ExistingDir;
                info = new ProcessedFileInfo(pair.Source, AssociatedCommand.Configuration, DirectoryClasses.ExistingDir);
            }
            else if (!shouldExclude && pair.Source.Exists && !AssociatedCommand.SelectionOptions.ExcludeLonely)
            {
                dirClass = DirectoryClasses.NewDir;
                info = new ProcessedFileInfo(pair.Source, AssociatedCommand.Configuration, DirectoryClasses.NewDir);
            }
            else if (pair.Destination.Exists && !AssociatedCommand.SelectionOptions.ExcludeExtra)
            {
                dirClass = DirectoryClasses.ExtraDir;
                info = new ProcessedFileInfo(pair.Destination, AssociatedCommand.Configuration, DirectoryClasses.ExtraDir);
                return false;
            }
            else
            {
                dirClass = DirectoryClasses.Exclusion;
                info = new ProcessedFileInfo(pair.Source, AssociatedCommand.Configuration, DirectoryClasses.Exclusion);
            }

            return !shouldExclude;
        }


        /// <inheritdoc cref="SelectionOptionsExtensions.ShouldExcludeJunctionDirectory(SelectionOptions, IDirectorySourceDestinationPair)"/>
        public bool ShouldExcludeJunctionDirectory(IDirectorySourceDestinationPair pair) => AssociatedCommand.SelectionOptions.ShouldExcludeJunctionDirectory(pair.Source);

        /// <inheritdoc cref="SelectionOptionsExtensions.ShouldExcludeDirectoryName(SelectionOptions, IDirectorySourceDestinationPair, ref Tuple{bool, Regex}[])"/>
        public bool ShouldExcludeDirectoryName(IDirectorySourceDestinationPair pair) => AssociatedCommand.SelectionOptions.ShouldExcludeDirectoryName(pair.Source.FullName, ref DirectoryNameRegexExclusions);

        #endregion

        #region < ShouldCopyFile >

        /// <inheritdoc cref="SelectionOptionsExtensions.ShouldCopyFile(IRoboCommand, IFileSourceDestinationPair, ref Regex[], ref Regex[], out ProcessedFileInfo)"/>
        public virtual bool ShouldCopyFile(IFileSourceDestinationPair pair, out ProcessedFileInfo info)
            => AssociatedCommand.ShouldCopyFile(pair, ref IncludeFileNameRegexField, ref ExcludeFileNameRegexField, out info);

        /// <inheritdoc cref="SelectionOptionsExtensions.ShouldCopyFile(IRoboCommand, IFileSourceDestinationPair, ref Regex[], ref Regex[], out ProcessedFileInfo)"/>
        public bool ShouldCopyFile(FileInfo source, FileInfo destination, out ProcessedFileInfo info)
            => ShouldCopyFile(new FileSourceDestinationPair(source,destination), out info);

        #endregion

        #region < Purge >

        /// <inheritdoc cref="CopyOptionsExtensions.ShouldPurge(IRoboCommand, IFileSourceDestinationPair)"/>
        public bool ShouldPurge(IFileSourceDestinationPair pair)
            => AssociatedCommand.ShouldPurge(pair);

        #endregion

        #region < Apply Attributes >

        /// <inheritdoc cref="CopyOptionsExtensions.SetFileAttributes(CopyOptions, FileInfo)"/>
        public void ApplyAttributes(FileInfo destination)
        {
            if (FileAttributesToApply.HasValue)
                destination.Attributes &= FileAttributesToApply.Value;
            if (FileAttributesToRemove.HasValue)
                destination.Attributes &= ~FileAttributesToRemove.Value;
        }

        /// <inheritdoc cref="CopyOptionsExtensions.SetFileAttributes(CopyOptions, FileInfo)"/>
        public void ApplyAttributes(IFileSourceDestinationPair pair)
            => ApplyAttributes(pair.Destination);

        #endregion

    }
}
